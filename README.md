Algorithms & Data Structures  Exam Project

This repository contains solutions to a university-level exam in Algorithms and Data Structures (PG4200). Each task demonstrates both conceptual understanding and practical implementation skills in Java. The topics cover foundational computer science principles that are crucial for building efficient and scalable software systems.

What This Project Demonstrates

-	Deep understanding of data structures (arrays, stacks, trees, graphs)
-	Implementation of classic algorithms (searching, sorting, traversal)
-	Ability to analyze and compare algorithmic efficiency
-	Experience with Big-O analysis, recursion vs. iteration, and computational complexity classes (P, NP, NP-Complete)
-	Skill in visualising and communicating technical concepts through graphical representations
-	Clean and correct Java code, with a focus on time and space efficiency

---

Task Breakdown

Task 1: Accessing Elements in a 1D Array

Topic: Memory address calculation in static arrays

Focus: Algorithmic thinking, pointer arithmetic

What I did:

-	Computed the address of a specific array index given a base memory address and element size.
-	Demonstrated understanding of how arrays are stored in memory.
-	
What I learned:

-	How low-level memory access works in arrays.
-	How to calculate the address of any element using a formula - critical when working with embedded systems or systems-level programming.

---

Task 2: Stack with getMin() in O(1)

Topic: Custom data structure design

Focus: Java implementation, auxiliary stacks

What I did:

-	Built a stack that supports push, pop, and getMin in constant time using two stacks.
-	Wrote clean, readable Java code with clear logic and internal consistency.
-	
What I learned:

-	How to extend basic data structures to support advanced operations efficiently.
-	The importance of auxiliary data structures in improving algorithmic performance.

---

Task 3: Deleting a Node in a Binary Search Tree

Topic: Binary Search Trees (BST)

Focus: Algorithm + graphical walkthrough

What I did:

-	Deleted a node with two children using the in-order successor strategy.
-	Presented a step-by-step visual and algorithmic explanation.

What I learned:

-	How BSTs maintain order and balance.
-	How deletion works across different node cases (leaf, one child, two children).
-	Improved skills in drawing and explaining algorithms visually.

---

Task 4: Merge Sort

Topic: Divide-and-conquer sorting

Focus: Algorithm and graphical breakdown

What I did:

-	Sorted an unsorted array using merge sort with visual breakdown of split and merge phases.

What I learned:

-	The recursive nature and efficiency of merge sort.
-	How to clearly present a sorting process for others to understand - important in team environments and code reviews.

---

Task 5: Fibonacci - Recursive vs. Iterative

Topic: Algorithm efficiency

Focus: Code comparison, complexity justification

What I did:

-	Implemented both recursive and iterative versions of the Fibonacci algorithm in Java.
-	Compared performance using Big-O notation and illustrated the difference graphically.

What I learned:

-	Why recursive solutions can be elegant but inefficient.
-	How to convert exponential-time algorithms to linear-time through iteration and memoization patterns.

---

Task 6: Complexity Classes (P, NP, NP-Complete)

Topic: Computability and Complexity Theory

Focus: Short-form conceptual explanations with real-life examples

What I did:

-	Explained major complexity classes and Big-O notation with practical analogies.
-	Connected theoretical knowledge to real-world problem-solving.

What I learned:

-	How to articulate complex theoretical ideas simply and clearly.
-	Why computational complexity is essential when designing scalable systems.

---

Technologies Used

-	Java (standard libraries)
-	Visual diagrams (hand-drawn and AI-generated)
-	Markdown & Git for documentation and version control

---

Key Takeaways

-	Efficient problem-solving is not just about code, but understanding when and why different algorithms and data structures are optimal.
-	Visualising and explaining your thought process is just as important as writing correct code â€” especially in collaborative work environments or interviews.
-	This project reflects not just technical ability, but also clarity in communication and depth in reasoning.

---

Contact

If you're a recruiter or developer interested in discussing this project or related work, feel free to reach out via my GitHub profile or LinkedIn - www.linkedin.com/in/anders-myhrvang-9a6629339.

